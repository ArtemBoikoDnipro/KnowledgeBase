+15 - Як створюється Spring контекст у Servlet контейнері. Реалізація аналога Spring IoC
{t 1-14-39} [in-KB spring-2022-07-30-18-38]

https-//www.youtube.com/watch?v=74gjdKSJGwE
Як створюється Spring контекст у Servlet контейнері? Реалізація свого аналога Spring IoC
t 1-14-38








00-00...04-43

нарезка, не конспектировать








05-36...06-21

главная цель Spring

сопосбствует DECOUPLING, разделяя логику и инициализацию объектов

для проекта нужно создать много объектов,
эти объекты нужно сконфигурировать (задать свойства),
для некоторых создать прокси, засетить зависимости

всем этим занимается Spring

мы занимаемся логикой приложения, а логикой инфраструктуры занимается Spring








06-21...08-29

основа платвормы - Spring и надстройка над ним в виде Spring Boot

самое важное в Spring это Context и Web MVC

что такое контекст (Демо 1)

контекст - это реестр бинов

Spring-у нужно создать и сконфигурировать за нас все переданные ему объекты,
эти объекты по завершении конфигурации доступны в контексте
в качестве бинов (объектов, которые нужны для работы)








08-29...15-16

Collections.emptyList();

какие maven зависимости нужны для создания Spring контекста

<spring-context>

самый простой способ создать Spring контекст

new AnnotationConfigApplicationContext(SomeClass.clss)

context.getBean(SomeClass.clss)

для RestTemplate нужна зависимость
<spring-webmvc>

подключаем Jackson
<jackson-databind>

restTemplate.getForObject("url", JsonNode.class)








15-28...17-15

варианты создания контекста

передать классы в конструктор контекста

интерфейс ApplicationContext

xml-конфигурация

как создать контекст на базе пакета

new App...Context("some.package")

и спринг пройдётся сканером по все классам пакета

непроаннотированные, не числящиеся в xml-конфигурации
или не переданные в конструктор контекста классы
для спринга не интересны, он их "не видит"








17-15...18-26

поскольку на НЕсвои классы мы не можем поставить @Component,
то делаем конфиг-класс и аннотируем его как @Configuration

и в конфиг-классе пишем фабричные методы для НЕсвоих классов,
помечая данные методы как @Bean








18-28...23-06

инжекция зависимости (dependency injection) через @Autowired

StreamSupport.stream(...)

конфигурация, которую мы передаёт спрингу - это его стартовая точка

если не указана аннотация @Autowired, но поле final,
то Spring заинжектит бины через конструктор

@RequiredArgsConstructor

можем передать конфиг-класс в конструктор контекста,
предварительно пометив этот конфиг-класс через @ComponentScan("some.package")

мы МОЖЕМ посетить конфиг-класс как @Component,
и это будет работать (поскольку @Configuration является @Component),
но это будет работать НЕПРАВИЛЬНО

т.к. у @Configuration класса есть дополнительная логику,
которая создаёт прокси

у @Configuration класса бины будут НЕ просто вызываться,
а у компонента @Component методы будут ПРОСТО ВЫЗЫВАТЬСЯ,
и потому будет просто создаваться новый бин
при каждом запросе на предоставление этого бина








23-10...23-51

коротко о Spring IoC

контекст - реестр бинов

мы задаём спрингу некую конфигурацию разными способами

есть стартовая точка, с которой Spring
начинает строить контекст (место, где мы создаём new App...Context)

и затем можем вручную на контексте получать бины через .getBean(...),
но так редко делаем, а чаще всего инжектим бины в нужные классы








23-51...27-28

как создать Spring контекст в Servlet контейнере (Демо 2)

<javax.servlet-api>

создаём NasaPicturesServlet

инициализируем Spring контекст через метод init(ServletConfig),
который вызывается единожды при инициализации сервлета

как получить доступ к Servlet контексту

servletConfig.getServletContext();

сохраняем Spring контекст как атрибут Servlet контекста

servletContext.setAttribute("context", springContext);








27-37...29-50

как получить доступ к Spring контексту во время обработки запроса

req
.getServletContext()
.getAttribute("context");

springContext.getBean(Clazz.class);

ServletContext общий для всего приложения

Session общая для запросов/ответов по одному пользователю








29-50...31-35
32-34...32-54

пакуем всё в war и деплоим в Tomcat

<packaging>war

build plugins plugin
<maven-war-plugin>

добавляем 9-й Tomcat в конфигурацию запуска
(10-й работает уже с Jakarta пакетами)

лишний слэш в маппинге сервлета влияет








32-55...33-55
34-01...34-22

что происходит, когда мы посылаем запрос на Servlet,
внутри которого есть Spring

SerrvletContext - это просто мапа атрибутов,
что туда положим, то там и будет








34-30...38-20

как настроить Spring MVC,
чтобы он создавал Servlet контекст (Демо 3)

@RestController

конфигурация Servlet контекста

AbstractAnnotationConfigDispatcherServletInitializer
абстрактный класс с 3-мя методами для конфигурации DispatcherServlet

с 3-й версии севрлетов мы можем имплементировать
интерфейс WebApplicationInitializer
и Tomcat первым делом вызовет метод onSturtup(ServletContext)








38-20...40-12

getRootConfigClasses()
new Clazz[]{Config.class}

getServletConfigClasses()
здесь ничего не указываем

getServletMappings()
указываем маппинг DispatcherServlet
new Strin[]{"/"}

когда war файл развёртывается в Tomcat-е,
в первую очередь создаётся инстанс DispatcherServlet
с заданным ему маппингом, затем создаётся СПРИНГОВЫЙ WebApplicationContext
на основе переданного массива конфиг-классов в методе getRootConfigClasses(),
и этот СПРИНГОВЫЙ контекст будет засечен как атрибут в СЕРВЛЕТНОМ контексте








40-12...43-12

для конфиг-класса ставим @EnableWebMvc,
чтобы посоздавались вэб бины и работали контроллеры

для чего нужна аннотация @EnableWebMvc

без аннотации @EnableWebMvc у нас будет не вэб-контекст,
а обычный контекст и у нас не добавляются дефолтные mvc бины,
нужные для работы вэб-контекста (хэндлеры, мапперы)

оговорился, @EnableWebMvc над @Configuration классом ставим








43-16...43-45
44-05...44-54

деплоим Spring MVC app в Tomcat

DispatcherServlet создаёт нам конфиг спринга

запрос попадает на DispatcherServlet, который его парсит
и по URL находит нужный контроллер и вызывает подходящий метод контроллера








44-54...49-06

как в Spring контроллере получить доступ к Servlet контексту

поле
private final HttpServletRequest

какие атрибуты Spring MVC добавляет в Servlet контекст

req
.getServletContext()
.getAttributeNames();

WebApplicationContext.ROOT
это одно из имён атрибутов, здесь хранится спринговый контекст

класс с длинным названием Abstract...ServletInitializer вызывается Tomcat-ом,
поскольку этот класс имплементирует интерфейс WebApplicationInitializer

Evaluate в дебаг-режиме








49-17...51-05

что такое иерархический контекст

есть ServletContext, а есть RootContext, поэтому два метода
в классе Abstract...ServletInitializer просят массивы классов

RootConfig classes это спринговые конфиг-классы,
которые не касаются сервлетов

но поскольку везде используется один сервлет (DispatcherServlet),
то у него есть только один RootConfig

итог: у нас есть один инстанс DispathcerServlet,
который в себе содержит весь спринговый контекст








51-11...53-57

Q&A

DispatcherServlet - главный, он уже делегирует
обработку запросов контроллерам

есть НЕ сохранить спринговый контекст
как атрибут СЕРВЛЕТНОГО контекста,
то GarbageCollector его просто зачистит

если ссылку на спринговый контекст не сохранить в DispatcherServlet,
то спринговый контекст пропадёт

сервлетный контекст живёт на протяжении всей работы приложения








53-57...57-56

разбираем код DispatcherServlet

делегирует работу делегирует HandlerMapper-ам и ViewResolver-ам

на старте приложения в методе onStartup(ServletContext)
в DispatcherServlet регистрируется ServletContext








58-17...59-25
59-46...1-00-48

когда Tomcat развораичает war, он находит класс,
который имплементирует интерфейс WebApplicationInitializer

а Spring уже имплементировал этот интерфейс
через тот длинющий абстрактный класс Abstract...ServletInitializer

и мы просто расширяем ту логику, которую добавил сам Spring
(добавляем маппинг DispatcherServlet и конфиг-классы)

Tomcat вызывает код, который Spring ему подготовил

Spring просто хитрый, он знает о контракте Servlet API и знает,
что если подсунуть инстанс имплементатора WebApplicationInitializer,
то первым делом будет вызван метод onStartup(ServletContext),
а класс, который имплементит этот интерфейс,
он спринговый (уже реализован), а мы его расширяем,
заэкстендившись от абстрактного класса с длинющим именем

итого в спринговом приложении будет создан
только один сервлет (DispatcherServlet)








1-01-25...1-13-44

как создать свой аналог Spring IoC (Демо 4)

Stream API style

getBean(...)

план построения кастомного котекста:
-просканировать пакет
-найти все нужные классы
-создать на их основае бины
-положить в мапу контекста

для сканирования пакета на предмет требуемых классов - библиотека <reflections>

не забываем Retention Runtime для аннотации








1-13-44...1-14-35

ApplicationContext - это хэш-мапа объектов

как он создаётся - через Reflection API

и сохраняется он как атрибут ServletContext








всё
----------







