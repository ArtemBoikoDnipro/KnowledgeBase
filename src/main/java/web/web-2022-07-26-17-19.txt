+11 - Вступ до Java Web 3-рівнева архітектура
{t 29-06} [in-KB web-2022-07-26-17-19]

https-//www.youtube.com/watch?v=IQuHCJn4rds
Вступ до Java Web. 3-рівнева архітектура
t 29-06








00-00...02-20

нарезка, не конспектировать








04-13...06-25

обзор Enterprise систем

backend для web-приложений

клиент-серверная архитектура

есть клиент, есть сервер, они общаются по HTTP протоколу через интернет,
клиент отправляет запрос на сервер, сервер отвечает html страницей








06-25...11-37

3-уровневая архитектура
3-tier architecture

это 3 отдельные физические единицы

Psesentation
Service
Data

3-шарова архитектура - ЛОГИЧЕКОЕ разделение приложения на то как мы:
-представляем данные (Psesentation)
-определяем бизнес-логику (Service)
-отделяем код взаимодействия с БД (Persistence)

уровень (Tier) vs слой (Layer)
Tier - физическое разделение, Layer - разделение логики

MVC - это часть Psesentation layer








11-38...14-36

стэк технологий

Presentation:
Vue
React

Application (Service):
Spring Boot
Tomcat
Spring Security
Spring Data

Spring Boot приложение запущено в томкэте

Data:
PostgreSQL/MySQL

между бэком и фронтом ходят json-ы по HTTP протоколу

Spring Data JPA работает поверх Hibernate,
преобразует джаваОбъект<->рядокБД








14-40...17-22

обработка web-запроса под капотом

есть сервер, на нём установлена java,
значит есть JVM, на котором запущен контейнер сервлетов,
внутри которого запущено 3-хслойное SpringBoot приложение

у контейнера сервлетов есть пул потоков, Thread Pool (200 потоков по умолчанию в Tomcat)

каждому клиенскому запросу выделяется 1 поток,
в котором выполняется логика всех 3-х слоёв

поток закреплён за запросом и как только request отправлен -
значит поток отработал и он возвращается обратно в пул








17-32...21-13

поток не закрепляется за сессией, поток закрепляется за запросом

в рамках одной сессии может быть 10-100-... запросов

200 - это maxSize, это количество потоков НЕ увеличивается,
запрос отрабатывает быстро, дело секунды

на момент старта Tomcat мы должны понимать
какая у нас может быть нагрузка и делать scaling на ходу не получится

но обычно всё в облаках, и так скейлятся сервисы,
создаётся новый инстанс сервиса и происходит
балансирование нагрузки между инстансами








21-21...22-00

когда из стэка делается метод pop(),
то метод-фрейм оттуда забирается,
поэтому и не нужно чистить стэк

т.е. при возвращении потока в пул сервлет-контейнера
у потока все методы отработали, стэк пустой








22-05...23-45

почему 200 - это приблизительное оптимальное количество потоков








23-55...26-28

backend приложение обслуживает веб/мобильное/десктоп приложение

наше приложение получает запросы по сети, выполняет логику,
выгружает данные и БД и возвращает результат

микросервисы

в них не обязательно присутствуют все 3 слоя, может быть комбинация 1-2-3 слоёв

в совокупности микросервисы обеспечивают такую работу, какую обеспечивал бы монолит

spring cloud
для коммуникации между микросервисами, чтобы сделать систему единой








26-42...27-27

что лежит в основе web-разработки на Java

очень упрощённо - почти вся коммуникация - отправка через сеть json-ов по HTTP








27-27...28-40

пример бэка, который возвращает JSON

URL указывает на HTTP endpoint

браузер (клиент) отправляет HHTP GET запрос на сервер
и с сервера возвращается ответ в видео JSON

данные можно пославть в разном виде: бинарные данные, HTML, XML, JSON

Presentationn layer определяет в каком виде мы данные представляем








всё
----------







