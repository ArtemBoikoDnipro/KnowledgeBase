+09 - Багатопоточніcть в Java. Merge Sort на ForkJoin фреймворку
{t 1-04-57} [in-KB concur-2022-07-25-12-27]

https://www.youtube.com/watch?v=sG6W1_mAoSM
Багатопоточніcть в Java. Сортування Злиттям (Merge Sort) на Fork/Join фреймворку
t 1-04-56








00-00...03-35

нарезка, не конспектировать








03-35...06-28
06-57...07-50
07-58...08-17

почему важно изучать многопоточность

потоки создаются в контейнере сервлетов, чтобы обрабатывать запросы клиентов

2 причины, почему многопоточность сложная

1) не все операции атомарны - в многопоточности
может быть проблема неконсистентности данных

2) не все данные разделяемые - поэтому данные могут быть устаревшими

поэтим двум причинам мы должны синхронизировать потоки








08-19...10-24

модель мапяти Java

Metaspace
Heap
Stack

Stack создаётся для каждого потока свой
Heap разделяемый между потоками

две потенциальные проблемы

поток 1 в процессе изменения объекта,
тогда как поток 2 пытается получить доступ к этому объекту -
может наступить неконсистентность данных

поток 1 изменил объект, он пребывает в консистентном состоянии,
но эти изменения ещё не поступили в разделяемую между потоками память








10-30...15-31

1. Проблема неконсистентности данных

Heap, в нём хранится экземпляр класса,
у него есть поле,
два потока имеют ссылки на этот объект,
поток 1 инкрементит поле,
поток 2 одновременно инкременитт поле,
и т.к. операция неатомарна,
то поле инкрементнулось не на +2 суммарно,
а на +1

2. Проблема устарелости данных

с Heap-ом и Stack-ом мы работаем на уровне оперативной памяти (RAM)

а процессор берёт поле из RAM и инкрементит его у себя в L1/L2/L3 кэше
или в регистре и проинкрементил уже до 10_000,
но ещё не записал результат обратно в RAM

т.е. информация актуальна для потока,
но она не хранится ы разделяемой памяти, и поэтому устаревшая,
актуальные данные ещё не видимы всем потокам








15-31...16-30

цитата о многопоточности в Java

обычно нужно воздерживаться от работы с потоками напрямую








17-09...21-16

как запустить код в новом потоке

создаём объект класса Thread, передаём ему в конструктор Runnable интрефейс

код писал в
Multithreading_KB

Thread implements Runnable

thred.getState()
проверить состояние потока

NEW - до запуска потока
RUNNABLE - в работе
TERMINATED - после отработки








21-17...26-33

проблема неконсистентности

join()

volatile - говорит JVM, что поле нужно читать/записывать
в разделяемой между потоками памяти

т.е. процессор не будет у себя в ядре
кэшировать значение и там его инкрементить

но volatile не решает проблему неконсистентности,
т.к. потоки перезаписывают состояние друг друга

synchronized
ключевое слово, которое запрещает доступ
более чем одному потоку к разделяемому ресурсу








26-37...30-00

основнные "примитивы" многопоточности в Java

Thread
volatile
synchronized
wait(), notify(), notifyAll()

вся многопоточка основана на этих вещах








30-01...31-17
31-38...39-02

что должен знать Java-разработчик

Java Thread Model

как заблокировать поток

когда поток 1 вызывает синхронизированный код,
а другой поток 2 уже его выполняет - то поток 1 заблокирован (состояние BLOCKED)

Deadlock
потоки ждут друг друга и оба заблокированы (2 монитора)








39-19...41-26

synchronized блокирует потоки автоматически

wait, notify
для управления потокаи вручную

WAITING - когда поток попросили подождать

когда ждём некий ресурс








41-26...44-40

коротко о Concurrency Utils

синхронизаторы (Lock, Semaphore)

Atomics
позволяют атомарно делать инкремент/декремент, они не блокирующие

Concurrent Collections

ConcurrentHashMap

Executors

Fork/Join Framework








44-47...45-51

примеры Executors

много фабричных статических методов

ExecutorService es =
Executors.newFixedThreadPool(5);
es.execute(runnable);
es.shutdown();








46-18...47-33

Fork/Join framework
был добавлен в 7-й джаве

параллельные стримы, CompletableFeauture работают на базе него

построен на принципе разделяй и властвуй

есть такси, и мы оперируем категориями тасок, а не потоков

Fork/Join Pool (FJP) эти таксие выполняет








47-33...49-02

многопоточная сортировка слиянием (Merge Sort)

OurTask extends RecursiveTask<T>
если нужно возвращать какое-то значение

если НЕ нужно:
OurTask extends RecursiveAction

у него один метод compute(), который нужно переопределить (как run())

ForkJoinPool
 .commonPool()
 .invoke(new OurTask())

пул разделяем JVM между всеми потоками,
потоков в нём на 1 меньше, чем ядер на компьютере








49-02...56-21

в сортировке слиянием мы рекурсивно
делим массив на более маленькие,
когда доходим до 1 элемента, начинаем их мерджить

в F/J мы делим такси

создаём 2 массива

leftTask.fork();
rightTask.compute();
leftTask.join();

реализуем метод merge

задаём уловие выхода








56-25...58-09

самое интересное про Fork/Join framework

work stealing

если одни потоки быстрее закончат работу,
то они возьмут часть работы дргих потоков

т.о. мы более уверены, что работа будет распределена
более-менее равномерно между все потоками








58-10...1-02-22

как создать свой Fork/Join pool

JorkJoinPool pool = new JorkJoinPool(4);
pool.invoke(myTask);

Runtime
 .getRuntime()
 .availableProcessors() - 1

создаются эти 8-1 потоков при первом обращении к JorkJoinPool.commonPool(),
эти потоки общие для всего приложения

JorkJoinPool
 .commonPool()
 .getParallelism()
покажет количество потоков

почему важно знать об общем Fork/Join pool (ForkJoinPool.commonPool())








1-02-28...1-04-26

заключительное слово








всё
----------







