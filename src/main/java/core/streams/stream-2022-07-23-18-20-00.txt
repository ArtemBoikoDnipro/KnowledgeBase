+08 - Розбір Stream API Принципи роботи Колектори Optional API
{t 1-23-20} [in-KB stream-2022-07-23-18-20-00]

https://www.youtube.com/watch?v=arIwqmbO22g
Розбір Stream API: Принципи роботи, Колектори. Optional API
t 1-23-20








00-00...03-30

нарезка основных моментов, не конспектировать,
просто послушать и посмотреть








04-00...12-12

эффективное обучение

нужно не заучивать, а иметь понимание как правильно сделать

merge sort - варианты как сделать (через многопоточность)








12-12...14-32

императивный vs декларативный стиль

императивный стиль: пишем код, указываю детальную инструкцию
как мы хотим выполнить логику

декларативный стиль: указываем что мы хотим получить

преимущество декларативного стиля - не пишем детали,
а значит реализация может быть разной

в декларативном стиле мы делегируем имплементацию
тому, кто будет выполнять код

если нам нужен бОльший контроль над каждой итерацией -
декларативный стиль может не подойти








14-34...16-18

Stream API - наиболее из всей джавы использует декларативный стиль

преимущества использования Stream API

Stream API - это не замена коллекциям, это инструмент,
позволяющий работать с коллекциями в декларативном стиле

итого получаем более краткий код, который при этом легко запараллелить








16-19...17-34

откуда появились стримы в Java

основная проблема, которую решает stream api -
проще работать с коллекциями,
меньше кода, и код более понятен








17-35...21-57

разбор Stream API в коде

интерфейс Stream<T>

получаем стрим мы из коллекции, массива

Stream.of(array) с 9-й джавы
Arrays.stream(array)

стрим - временный объект на то время, когда мы хотим
поработать с коллекцией в декларативном стиле

forEach(Consumer)

stream().filter(Predicate)

.collect(Collectors.toList())








21-57...24-12

stream().map(Function)
трансформирует каждый элемент стрима

итого: мы либо принимаем и обрабатываем,
либо фильтруем, либо трансформируем








24-12...26-55

промежуточные и терминальные операции

терминальная операция заканчивает работу со стримом,
после этого со стримом больше работать нельзя, он закрывается

промежуточные операции всегда возвращают стрим
(но иногда другого типа, если мы map используем)

forEach - терминальная операция, она void, т.е. не возвращает стрим








27-00...32-54

сколько итераций выполняется в стриме

сколько элементов - столько и итераций

до момента вызова терминальной операции ничего не происходит,
стрим собирает операции в некую очередь,
потом при вызове терминальной операции
стрим берёт из очереди элемент
и делает на нём вре промежуточные операции
в рамках одной итерации

никакая логика стрима не будет вызвана,
пока не вызвана терминальная операция








32-54...35-05

Q&A по Stream API

лучше стрим не сохранять в локальную переменную








35-05...37-14

операция reduce - получить со всего стрима одно значение

бинарная функция

BynaryOperator

в reduce можно передать дефолтное значение








37-22...41-08

что делает flatMap

flatMap - то же самое, что и map, но более узкий (специфичный) случай map

чтобы избежать вложенных стримов, т.е. у нас получается стрим стримов

flatMap принимает функцию, которая перемапливает элемент стрима
в стрим некого типа, который и возвращает:

flatMap(Finction<T, Stream<R>>)








41-11...46-07

для работы с примитивными типами есть специальные стримы

IntStream
LongStream
DoubleStream

mapToDouble возвращает DoubleStream
mapInt      возвращает IntStream

mapToDouble(BigDecimal::doubleValue)

и мы получаем новые методы
sum()
min()
max()

.boxed()
и мы снова возвращаемся к Stream<Double>

.mapToObj(val -> ...)
если нужен сложный маппинг примитива в объект








46-12...47-38

лучшие практики: открываем стрим, поработали с ним, закрыли,
не передаём стримы как параметр и не сохраняем в локальные переменные

если работаем с примитивами, то не нужно усложнять
и делать стрим объектов, работаем с IntStream и т.п.

если в лямбде есть фигурные скобки -
такую логику нужно выносить во вспомогательный метод,
а в стриме просто сделать ссылку на метод








47-40...50-34

как генерировать стрим

Stream.generate(Supplier)

это будет бесконечный стрим, поэтому делаем .limit(10)

как имплементировать итерацию на стриме

Stream
.iterate("A", s -> s + s)
.limit(10)
.forEach(sout);

Stream
.iterate(1, i -> i + 1)
.limit(10)
.forEach(sout); // 1,2,3,...10








50-35...52-24

что такоеколлектор и для чего он нужен (Collector)

Collector - интерфейс, абстракция, которая позволяет описать логику того,
как и куда собрать элементы стрима

класс Collectors
toList()
toSet()
toMap(Function, Function)








52-26...53-33

как собрать (collect) элементы в мапу

передать 2 функции: маппер для ключа, маппер для значения

toMap(Account::getId, Account::getEmail)








53-35...55-58

почему на стримах хорошо учить дженерики (generics)

для чего глубокое понимание








56-10...1-00-00

как погрупиировать элементы (groupingBy)

Collectors
.groupingBy(Function)

Collectors
.groupingBy(Function, Collector)

Downstream collectors








1-01-42...1-03-53

filter(...)

.collect(filtering(...))








1-04-03...1-05-48

параллельные стримы

Stream API позволяет легко запустить код в параллельных потоках

list.parallelStream()

stream.parallel()

параллельные стримы работает
за счёт общего пула потоков - common Fork/Join pool

Fork/Join - фреймворк для работы с потоками, добавлен в 7-й джаве

common Fork/Join - он статический,
инициализируется при первом обращении к нему

все стримы использую один общий пул потоков

по умолчанию пул содержит столько потоков,
сколько ядер на компьютере








1-05-48...1-08-03

потоков может не хватить

часто их использовать не нужно

правила использования параллельных стримов

источник данных для параллельного стрима
должен легко делиться (ArrayList)

Spliterator описывает логику разделения коллекции

количество элементов коллекции должно быть существенным (100_000+)

создать потоки, раздать им работу,
а затем смерджить их работу - на это может пойти больше времени,
чем на обычный стрим








1-08-03...1-09-43
1-09-58...1-10-44

наша логика в стриме должна легко параллелиться

операция reduce, найти минимальное значение - да, легко параллелится

сложная логика, требующая постоянной синхронизации
будет работать намного медленнее, чем в одном потоке

в любом случае протестировать скорость параллельной работы и НЕпараллельной

list.parallelStream()

stream.parallel()








1-10-47...1-12-49

Optional API
позволяет обрабатывать nullable объекты в более безопасной и краткой форме

проблема - вызов чего угодно на null объекте - вылет по NullPointerException (NPE)

разбор Optional<T> класса

Optional.of()
Optional.ofNullable()

ofNullable() возвращает empty(), если объект null,
а empty() это просто new Optional<>(), у которого поле value == null








1-12-49...1-16-10

API - это куча методов, которые обеспечивают
простую работу с чем-то

Optional это как коллекция на 1 элемент

orElse(defaultValue)

если наш метод может не вернуть Account,
мы пишем как return-type Optional<Account>

если нам подходит бросить исключение,
если не нашли - orElseThrow(() -> new ...)

и если м уже прописали orElseThrow,
то вызов метода вернёт не Optional<Account>, а Account

если не подходит кинуть исключение - orElse(Account)








1-16-18...1-19-22

разница между orElse и orElseGet

orElse - если дефолтное значение УЖЕ есть,
если же нужно сходить в базу

orElseGet - на объекте Supplier вызовется метод get
только если Optional пустой

orElseGet(Supplier) мы используем, если нужны какие-то дополнительные действия,
чтобы получить сущность, которой сейчас нет в наличии,
если дефолтная сущность уже есть, мы вызываем orElse(entity)








1-19-24...1-21-34

как перейти от объекта к его полю

метод map

.map(Account::getBalance)
и возвращаемое значение уже Optional<BigDecimal>

метод flatMap
чтобы избавиться от вложенного Optional,
в тех случаях когда метод возвращает Optional

тогда вызываем вместо map
.flatMap(Account::getBalance)








1-21-59...1-23-08

где ещё используется декларативный стиль - реактивное программирование








всё
----------







