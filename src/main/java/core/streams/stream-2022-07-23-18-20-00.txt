00-00...03-30

нарезка основных моментов, не конспектировать, просто послушать и посмотреть








04-00...12-12

эффективное обучение

нужно не заучивать, а иметь понимание как правильно сделать

merge sort - варианты как сделать (через многопоточность)








12-12...14-32

императивный vs декларативный стиль

императивный стиль: пишем код, указываю детальную инструкцию как мы хотим выполнить логику

декларативный стиль: указываем что мы хотим получить

преимущество декларативного стиля - не пишем детали, а значит реализация может быть разной

в декларативном стиле мы делегируем имплементацию тому, кто будет выполнять код

если нам нужен бОльший контроль над каждой итерацией - декларативный стиль может не подойти








14-34...16-18

Stream API - наиболее из всей джавы использует декларативный стиль

преимущества использования Stream API

Stream API - это не замена коллекциям, это инструмент, позволяющий работать с коллекциями в декларативном стиле

итого получаем более краткий код, который при этом легке запараллелить








16-19...17-34

откуда появились стримы в Java

основная проблема, которую решает stream api - проще работать с коллекциями, меньше кода, и код более понятен








17-35...21-57

разбор Stream API в коде

интерфейс Stream<T>

получаем стрим мы из коллекции, массива

Stream.of(array) с 9-й джавы
Arrays.stream(array)

стрим - временный объект на то время, когда мы хотим поработать с коллекцией в декларативном стиле

forEach(Consumer)

stream().filter(Predicate)

.collect(Collectors.toList())








21-57...24-12

stream().map(Function)
трансформирует каждый элемент стрима

итого: мы либо принимаем и обрабатываем, либо фильтруем, либо трансформируем








24-12...26-55

промежуточные и терминальные операции

терминальная операция заканчивает работу со стримом, после этого со стримом больше работать нельзя, он закрывается

промежуточные операции всегда возвращают стрим (но иногда другого типа, если мы map используем)

forEach - терминальная операция, она void, т.е. не возвращает стрим








27-00...32-54

сколько итераций выполняется в стриме

сколько элементов - столько и итераций

до момента вызова терминальной операции ничего не происходит, стрим собирает операции в некую очередь, потом при вызове терминальной операции стрим берёт из очереди элемент и делает на нём вре промежуточные операции в рамках одной итерации

никакая логика стрима не будет вызвана, пока не вызывана терминальная операция








32-54...35-05

Q&A по Stream API

лучше стрим не сохранять в локальную переменную








35-05...37-14

операция reduce - получить со всего стрима одно значение

бинарная функция

BynaryOperator

в reduce можно передать дефолтное значение








37-22...41-08

что делает flatMap

flatMap - то же самое, что и map, но более узкий (специфичный) случай map

чтобы избежать вложенных стримов, т.е. у нас получается стрим стримов

flatMap принимает функцию, которая перемапливает элемент стрима в стрим некого типа, который и возвращает:

flatMap(Finction<T, Stream<R>>)








41-11...46-07

для работы с примитивными типами есть специальные стримы

IntStream
LongStream
DoubleStream

mapToDouble возвращает DoubleStream
mapInt      возвращает IntStream

mapToDouble(BigDecimal::doubleValue)

и мы получаем новые методы
sum()
min()
max()

.boxed()
и мы снова возвращаемся к Stream<Double>

.mapToObj(val -> ...)
если нужен сложный маппинг примитива в объект








46-12...47-38

лучшие практики: открываем стрим, поработали с ним, закрыли, не передаём стримы как параметр и не сохраняем в локальные переменные

если работаем с примитивами, то не нужно усложнять и делать стрим объектов, работаем с IntStream и т.п.

если в лямбде есть фигурные скобки - такую логику нужно выносить во вспомогательный метод, а в стриме просто сделать ссылку на метод








47-40...50-34

как генерировать стрим

Stream.generate(Supplier)

это будет бесконечный стрим, поэтому делаем .limit(10)

как имплементировать итерацию на стриме

Stream
.iterate("A", s -> s + s)
.limit(10)
.forEach(sout);

Stream
.iterate(1, i -> i + 1)
.limit(10)
.forEach(sout); // 1,2,3,...10








50-35...52-24

что такоеколлектор и для чего он нужен (Collector)

Collector - интерфейс, абстракция, которая позволяет описать логику того, как и куда собрать элементы стрима

класс Collectors
toList()
toSet()
toMap(Function, Function)








52-26...53-33

как собрать (collect) элементы в мапу

передать 2 функции: маппер для ключа, маппер для значения

toMap(Account::getId, Account::getEmail)








53-35...55-58

почему на стримах хорошо учить дженерики (generics)

для чего глубокое понимание








56-10...1-00-00

как погрупиировать элементы (groupingBy)

Collectors
.groupingBy(Function)

Collectors
.groupingBy(Function, Collector)

Downstream collectors








1-01-42...1-03-53

filter(...)

.collect(filtering(...))
